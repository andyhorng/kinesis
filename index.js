// Generated by CoffeeScript 1.6.3
(function() {
  'use strict';
  var AWS, Bacon, debug, print, _;

  AWS = require('aws-sdk');

  Bacon = require('baconjs');

  _ = require('underscore');

  debug = require('debug');

  print = debug('creek:kinesis');

  exports.listen = function(StreamName, opts) {
    var kinesis;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      region: 'us-east-1'
    });
    kinesis = new AWS.Kinesis(opts);
    return Bacon.fromNodeCallback(kinesis, 'describeStream', {
      StreamName: StreamName
    }).flatMap(function(_arg) {
      var Shards;
      Shards = _arg.StreamDescription.Shards;
      return Bacon.fromBinder(function(sink) {
        _.chain(Shards).pluck('ShardId').each(function(ShardId) {
          var options;
          options = {
            StreamName: StreamName,
            ShardId: ShardId,
            ShardIteratorType: 'LATEST'
          };
          return kinesis.getShardIterator(options, function(error, d) {
            var iterateShard;
            if (error != null) {
              return sink(new Bacon.Error(error.message));
            }
            iterateShard = function(ShardIterator) {
              return kinesis.getRecords({
                ShardIterator: ShardIterator
              }, function(error, result) {
                if (error != null) {
                  return sink(new Bacon.Error(error.message));
                }
                print('got ' + JSON.stringify(result));
                _.chain(result.Records).pluck('Data').map(function(d) {
                  var buf, e;
                  buf = new Buffer(d, 'base64').toString();
                  try {
                    return JSON.parse(buf);
                  } catch (_error) {
                    e = _error;
                    print('bad json');
                    return new Bacon.Error(e.message);
                  }
                }).each(sink);
                if (result.Records.length > 0) {
                  return iterateShard(ShardIterator);
                } else {
                  return setTimeout(_.partial(iterateShard, ShardIterator), 200);
                }
              });
            };
            return iterateShard(d.ShardIterator);
          });
        });
        return function() {};
      });
    });
  };

  exports.publish = function(StreamName, opts) {
    var bus, kinesis;
    if (opts == null) {
      opts = {};
    }
    _.defaults(opts, {
      region: 'us-east-1'
    });
    kinesis = new AWS.Kinesis(opts);
    bus = new Bacon.Bus();
    bus.filter(_.isObject).map(function(d) {
      var encoded;
      encoded = (new Buffer(JSON.stringify(d))).toString('base64');
      return {
        StreamName: StreamName,
        Data: encoded,
        PartitionKey: d.log_id || _.uniqueId()
      };
    }).onValue(function(args) {
      print('publish ' + JSON.stringify(args));
      return Bacon.fromNodeCallback(kinesis, 'putRecord', args).onError(function(err) {
        return print('got error: ' + err);
      });
    });
    return bus;
  };

}).call(this);
